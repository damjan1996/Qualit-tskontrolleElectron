/**
 * Qualit√§tskontrolle Schema Installer
 * Automatische Installation des QC-Datenbankschemas
 */

const fs = require('fs');
const path = require('path');
require('dotenv').config();

// Database Client laden
const DatabaseClient = require('../db/db-client');

class QCSchemaInstaller {
    constructor() {
        this.dbClient = null;
        this.schemaPath = path.join(__dirname, '..', 'sql', 'quality-control-schema.sql');
    }

    async install() {
        console.log('üîß Qualit√§tskontrolle Schema Installation startet...\n');

        try {
            // 1. Datenbankverbindung herstellen
            console.log('üìä Verbinde mit Datenbank...');
            this.dbClient = new DatabaseClient();
            const connected = await this.dbClient.connect();

            if (!connected) {
                throw new Error('Datenbankverbindung fehlgeschlagen');
            }
            console.log('‚úÖ Datenbankverbindung erfolgreich\n');

            // 2. Pr√ºfe ob QC-Tabellen bereits existieren
            console.log('üîç √úberpr√ºfe vorhandene QC-Tabellen...');
            const tablesExist = await this.checkQCTablesExist();

            if (tablesExist.allExist) {
                console.log('‚úÖ Alle QC-Tabellen bereits vorhanden:');
                tablesExist.existing.forEach(table => console.log(`   ‚úì ${table}`));
                console.log('\nüìã Schema bereits installiert - keine Aktion erforderlich');
                return true;
            } else {
                console.log('‚ö†Ô∏è Fehlende QC-Tabellen gefunden:');
                tablesExist.missing.forEach(table => console.log(`   ‚ùå ${table}`));
                console.log('');
            }

            // 3. Schema-Datei lesen
            console.log('üìÑ Lade QC-Schema-Datei...');
            if (!fs.existsSync(this.schemaPath)) {
                throw new Error(`Schema-Datei nicht gefunden: ${this.schemaPath}`);
            }

            const schemaSQL = fs.readFileSync(this.schemaPath, 'utf8');
            console.log(`‚úÖ Schema-Datei geladen (${schemaSQL.length} Zeichen)\n`);

            // 4. Schema installieren
            console.log('üöÄ Installiere QC-Schema...');
            await this.executeSchemaSQL(schemaSQL);

            // 5. Installation verifizieren
            console.log('‚úÖ Schema-Installation abgeschlossen\n');
            console.log('üîç Verifiziere Installation...');

            const verificationResult = await this.verifyInstallation();
            if (verificationResult.success) {
                console.log('‚úÖ Installation erfolgreich verifiziert\n');
                console.log('üìä Installierte Objekte:');
                verificationResult.objects.forEach(obj => {
                    console.log(`   ‚úì ${obj.type}: ${obj.name}`);
                });
            } else {
                console.warn('‚ö†Ô∏è Verifikation teilweise fehlgeschlagen:', verificationResult.warnings);
            }

            console.log('\nüéâ Qualit√§tskontrolle Schema erfolgreich installiert!');
            console.log('üí° Die Anwendung kann jetzt mit QC-Funktionalit√§t gestartet werden.');

            return true;

        } catch (error) {
            console.error('\n‚ùå Schema-Installation fehlgeschlagen:', error.message);
            console.error('\nüîß L√∂sungsvorschl√§ge:');
            console.error('   1. √úberpr√ºfen Sie die Datenbankverbindung in .env');
            console.error('   2. Stellen Sie sicher, dass der Benutzer CREATE-Rechte hat');
            console.error('   3. F√ºhren Sie das Schema manuell aus:');
            console.error(`      sqlcmd -S ${process.env.MSSQL_SERVER} -d ${process.env.MSSQL_DATABASE} -i sql/quality-control-schema.sql`);
            return false;

        } finally {
            if (this.dbClient) {
                await this.dbClient.close();
            }
        }
    }

    async checkQCTablesExist() {
        const requiredTables = [
            'QualityControlSteps',
            'QualityControlAudit',
            'QualityControlConfig'
        ];

        const existing = [];
        const missing = [];

        for (const tableName of requiredTables) {
            try {
                const result = await this.dbClient.query(`
                    SELECT COUNT(*) as TableExists
                    FROM INFORMATION_SCHEMA.TABLES 
                    WHERE TABLE_NAME = ? AND TABLE_SCHEMA = 'dbo'
                `, [tableName]);

                if (result.recordset[0].TableExists > 0) {
                    existing.push(tableName);
                } else {
                    missing.push(tableName);
                }
            } catch (error) {
                missing.push(tableName);
            }
        }

        return {
            allExist: missing.length === 0,
            existing: existing,
            missing: missing,
            requiredCount: requiredTables.length,
            existingCount: existing.length
        };
    }

    async executeSchemaSQL(schemaSQL) {
        try {
            // SQL in einzelne Statements aufteilen (GO-separated)
            const statements = schemaSQL
                .split(/\r?\nGO\r?\n/i)
                .map(stmt => stmt.trim())
                .filter(stmt => stmt.length > 0 && !stmt.match(/^--/));

            console.log(`üìù F√ºhre ${statements.length} SQL-Statements aus...`);

            let successCount = 0;
            let errorCount = 0;

            for (let i = 0; i < statements.length; i++) {
                const statement = statements[i];

                // Skip pure comments
                if (statement.startsWith('--') || statement.startsWith('/*')) {
                    continue;
                }

                try {
                    await this.dbClient.query(statement);
                    successCount++;

                    // Progress indicator
                    if ((i + 1) % 5 === 0 || i === statements.length - 1) {
                        console.log(`   üìä Fortschritt: ${i + 1}/${statements.length} (${successCount} erfolgreich, ${errorCount} Fehler)`);
                    }

                } catch (error) {
                    errorCount++;

                    // Behandle bekannte nicht-kritische Fehler
                    if (this.isNonCriticalError(error)) {
                        console.warn(`   ‚ö†Ô∏è Warnung bei Statement ${i + 1}: ${error.message}`);
                    } else {
                        console.error(`   ‚ùå Fehler bei Statement ${i + 1}: ${error.message}`);
                        console.error(`   SQL: ${statement.substring(0, 100)}...`);

                        // Bei kritischen Fehlern stoppen
                        if (this.isCriticalError(error)) {
                            throw error;
                        }
                    }
                }
            }

            console.log(`‚úÖ Schema-Ausf√ºhrung abgeschlossen: ${successCount} erfolgreich, ${errorCount} Fehler/Warnungen`);

        } catch (error) {
            console.error('Fehler beim Ausf√ºhren des Schemas:', error);
            throw error;
        }
    }

    isNonCriticalError(error) {
        const nonCriticalPatterns = [
            'already exists',
            'bereits vorhanden',
            'cannot drop the index',
            'cannot drop the view',
            'duplicate key',
            'already granted'
        ];

        return nonCriticalPatterns.some(pattern =>
            error.message.toLowerCase().includes(pattern.toLowerCase())
        );
    }

    isCriticalError(error) {
        const criticalPatterns = [
            'access denied',
            'permission denied',
            'login failed',
            'cannot open database',
            'syntax error',
            'invalid object name' // Aber nur bei CREATE-Statements
        ];

        return criticalPatterns.some(pattern =>
            error.message.toLowerCase().includes(pattern.toLowerCase())
        );
    }

    async verifyInstallation() {
        try {
            const verificationResults = {
                success: true,
                objects: [],
                warnings: []
            };

            // 1. Tabellen pr√ºfen
            const tables = ['QualityControlSteps', 'QualityControlAudit', 'QualityControlConfig'];
            for (const tableName of tables) {
                try {
                    const result = await this.dbClient.query(`
                        SELECT COUNT(*) as Exists 
                        FROM INFORMATION_SCHEMA.TABLES 
                        WHERE TABLE_NAME = ?
                    `, [tableName]);

                    if (result.recordset[0].Exists > 0) {
                        verificationResults.objects.push({ type: 'Tabelle', name: tableName });
                    } else {
                        verificationResults.warnings.push(`Tabelle ${tableName} nicht gefunden`);
                    }
                } catch (error) {
                    verificationResults.warnings.push(`Fehler beim Pr√ºfen von Tabelle ${tableName}: ${error.message}`);
                }
            }

            // 2. Views pr√ºfen
            const views = ['vw_QCStepsWithSession', 'vw_DailyQCStats', 'vw_QCPerformanceOverview'];
            for (const viewName of views) {
                try {
                    const result = await this.dbClient.query(`
                        SELECT COUNT(*) as Exists 
                        FROM INFORMATION_SCHEMA.VIEWS 
                        WHERE TABLE_NAME = ?
                    `, [viewName]);

                    if (result.recordset[0].Exists > 0) {
                        verificationResults.objects.push({ type: 'View', name: viewName });
                    } else {
                        verificationResults.warnings.push(`View ${viewName} nicht gefunden`);
                    }
                } catch (error) {
                    verificationResults.warnings.push(`Fehler beim Pr√ºfen von View ${viewName}: ${error.message}`);
                }
            }

            // 3. Stored Procedures pr√ºfen
            const procedures = ['sp_StartQCStep', 'sp_CompleteQCStep', 'sp_AbortActiveQCSteps'];
            for (const procName of procedures) {
                try {
                    const result = await this.dbClient.query(`
                        SELECT COUNT(*) as Exists 
                        FROM INFORMATION_SCHEMA.ROUTINES 
                        WHERE ROUTINE_NAME = ? AND ROUTINE_TYPE = 'PROCEDURE'
                    `, [procName]);

                    if (result.recordset[0].Exists > 0) {
                        verificationResults.objects.push({ type: 'Procedure', name: procName });
                    } else {
                        verificationResults.warnings.push(`Procedure ${procName} nicht gefunden`);
                    }
                } catch (error) {
                    verificationResults.warnings.push(`Fehler beim Pr√ºfen von Procedure ${procName}: ${error.message}`);
                }
            }

            // 4. Basis-Funktionalit√§tstest
            try {
                // Test: QualityControlSteps Tabelle beschreiben
                await this.dbClient.query('SELECT TOP 1 * FROM QualityControlSteps WHERE 1=0');
                verificationResults.objects.push({ type: 'Test', name: 'QualityControlSteps Grundfunktion' });
            } catch (error) {
                verificationResults.warnings.push(`Funktionstest fehlgeschlagen: ${error.message}`);
                verificationResults.success = false;
            }

            return verificationResults;

        } catch (error) {
            return {
                success: false,
                objects: [],
                warnings: [`Verifikation fehlgeschlagen: ${error.message}`]
            };
        }
    }

    async installDefaultConfiguration() {
        try {
            console.log('‚öôÔ∏è Installiere Standard-QC-Konfiguration...');

            // Standard-Konfiguration f√ºr Qualit√§tskontrolle
            const result = await this.dbClient.query(`
                IF NOT EXISTS (SELECT * FROM QualityControlConfig WHERE SessionTypeName = 'Qualit√§tskontrolle')
                BEGIN
                    INSERT INTO QualityControlConfig (
                        SessionTypeName, RequiresBothScans, AllowParallelSteps, MaxParallelSteps,
                        DefaultPriority, AutoTimeoutMinutes, RequireQualityRating, RequireDefectCheck,
                        AllowRework, NotifyOnLongDuration, LongDurationThresholdMinutes, NotifyOnDefects
                    ) VALUES (
                        'Qualit√§tskontrolle', 1, 1, 10, 1, 120, 0, 1, 1, 1, 30, 1
                    );
                    SELECT 1 as Inserted;
                END
                ELSE
                    SELECT 0 as Inserted;
            `);

            if (result.recordset[0]?.Inserted) {
                console.log('‚úÖ Standard-QC-Konfiguration installiert');
            } else {
                console.log('‚ÑπÔ∏è Standard-QC-Konfiguration bereits vorhanden');
            }

        } catch (error) {
            console.warn('‚ö†Ô∏è Warnung: Standard-Konfiguration konnte nicht installiert werden:', error.message);
        }
    }
}

// CLI Interface
async function main() {
    const installer = new QCSchemaInstaller();

    console.log('=====================================');
    console.log('  Qualit√§tskontrolle Schema Installer');
    console.log('=====================================\n');

    const success = await installer.install();

    if (success) {
        console.log('\nüéØ N√§chste Schritte:');
        console.log('   1. Starten Sie die Anwendung: npm start');
        console.log('   2. Loggen Sie sich mit RFID-Tags ein');
        console.log('   3. Beginnen Sie mit der Qualit√§tskontrolle!\n');
        process.exit(0);
    } else {
        console.log('\nüí° Bei Problemen:');
        console.log('   1. √úberpr√ºfen Sie .env Datenbankeinstellungen');
        console.log('   2. F√ºhren Sie sql/quality-control-schema.sql manuell aus');
        console.log('   3. Kontaktieren Sie den Support\n');
        process.exit(1);
    }
}

// Automatisches Schema-Check und Installation
async function autoInstallIfNeeded() {
    const installer = new QCSchemaInstaller();

    try {
        console.log('üîç Automatische QC-Schema-√úberpr√ºfung...');

        // Quick check ohne vollst√§ndige Installation
        installer.dbClient = new DatabaseClient();
        const connected = await installer.dbClient.connect();

        if (!connected) {
            console.warn('‚ö†Ô∏è Datenbank nicht verf√ºgbar - QC-Schema-Check √ºbersprungen');
            return false;
        }

        const tablesExist = await installer.checkQCTablesExist();

        if (!tablesExist.allExist) {
            console.log(`‚ö†Ô∏è QC-Tabellen unvollst√§ndig (${tablesExist.existingCount}/${tablesExist.requiredCount})`);
            console.log('üöÄ Starte automatische Schema-Installation...');

            const success = await installer.install();
            return success;
        } else {
            console.log('‚úÖ QC-Schema vollst√§ndig vorhanden');
            return true;
        }

    } catch (error) {
        console.warn('‚ö†Ô∏è Automatische Schema-√úberpr√ºfung fehlgeschlagen:', error.message);
        return false;
    } finally {
        if (installer.dbClient) {
            await installer.dbClient.close();
        }
    }
}

// Export f√ºr andere Module
module.exports = {
    QCSchemaInstaller,
    autoInstallIfNeeded
};

// CLI Ausf√ºhrung
if (require.main === module) {
    main().catch(error => {
        console.error('‚ùå Unerwarteter Fehler:', error);
        process.exit(1);
    });
}